---

layout: post

title: "스위프트의 메모리 관리 기법"

date: 2020-06-04 17:23:22 +0530

categories: swift

---

<br>

<br>

매번 전달할 때마다 값을 복사해 전달하는 값 타입과는 달리 __참조 타입__은 하나의 인스턴스가 참조를 통해 여러곳에서 접근하기 때문에 언제 메모리에서 해제되는지가 중요한 문제이다. 인스턴스가 적절한 시점에 메모리에서 해제되지 않으면 한정적인 메모리 자원을 낭비하게 되며, 이는 _성능의 저하_ 로 이어지게 된다. 그래서 ARC를 사용한다.

<br>

<br>

## ARC(Automatic Reference Counting)

스위프트의 메모리 관리 기법인 ARC는 대체 무엇일까? 개념을 다져보자

<br>

ARC의 뜻

: 자동으로 메모리를 관리해주는 방식이다

: 더이상 필요하지 않은 클래스의 인스턴스를 메모리에서 해제하는 방식으로 동작이다



ARC는 스위프트에서 사용되는 메모리 관리 기법이다. 그렇다면 다른 프로그래밍 언어는 어떨까? 자바의 경우 가비지 컬렉션 기법을 사용한다. 둘의 차이를 비교해보자.

ARC와 가비지 컬렉션의 가장 큰 차이는 참조를 계산하는 시점이다. 

- ARC는 인스턴스가 언제 메모리를 해제되어야 할지를 컴파일과 동시에 결정한다
- 가비지 컬렉션은 프로그래 동작 중에 결정한다.

| 메모리 관리 기법 | ARC                                                          | 가비지 컬렉션                                                |
| :--------------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 참조 카운팅 시점 | 컴파일 시                                                    | 프로그램 동작 중                                             |
|       장점       | - 컴파일 당시 이미 인스턴스의 해제 시점이 정해져있어서<br />언제 메모리에서 해제될지 예측할 수 있다.<br />- 컴파일 당시 이미 인스턴스의 해제 시점이 정해져있어서 메모리 관리를 위한 자원을 추가할 필요가 없다. | - 상호 참조 상활 등의 복잡한 상황에서도 인스턴스를 해제할 수 있는 가능성이 높다.<br />- 특별히 규칙에 신경 쓸 필요가 없다. |
|       단점       | - ARC의 작동 규칙을 모르고 사용하면 인스턴스가 메모리에서 영원히 해제되지 않을 가능성이 있다. | - 프로그램 동작 외에 메모리 감시를 위한 추가 자원이 필요하므로 한정적인 자원 환경에서는 성능저하가 발생할 수 있다.<br />- 명확한 규칙이 없기 때문에 인스턴스가 정확히 언제 메모리에서 해제될지 예측하기가 어렵다. |

<br>

<br>

인스턴스가 언제 메모리에서 해제될지 예측할 수 있도록 ARC에 적용되는 몇 가지 규칙을 알아보자. 그리고 이런 규칙을 알지 못할 때 벌어질 수 있는 문제점과 해결방안도 알아보자



#### 1. 강한 참조(Strong)

> 뜻

- 인스턴스가 계속해서 메모리에 남아있어야 하는 명분을 만들어 주는 것
- 인스턴스는 참조 횟수가 0이 되는 순간 메모리에서 해제되지만 강한참조를 사용하면 참조횟수가 1 증가
- 강한참조를 사용하는 프로퍼티, 상수, 변수 등에 nil을 할당해주면 원래 자신에게 할당되어있던 인스턴스의 참조회수가 1감소

<br>

> 참조의 기본은 강한참조

<br>



#### 2. 약한 참조(Weak)

> 뜻

- 인스턴스의 참조 횟수를 증가시키지 않는다.
- 약한 참조를 사용한다면 자신이 참조하는 인스턴스가 메모리에서 해제될 수도 있다는 것을 예상해야한다. 왜냐하 자신이 참조 횟수를 증가시키지 않기 때문에 그 인스턴스를 강한 참조하던 프로퍼티나 변수에서 참조횟수를 감소시켜 0으로 만들면 자신이 참조하던 인스턴스가 메모리에서 해제되기 때문이다.

<br>



#### 3. 미소유 참조(Unowned)

> 뜻

- 약학 참조와 마찬가지로 인스턴스의 참조 횟수를 증가시키지 않는다.
- 자신이 참조하는 인스턴스가 항상 메모리에 존재할 것이라는 전제를 기반으로 동작한다.
- ! 미소유 참조는 참조하는 동안 해당 인스턴스가 메모리에서 해제되지 않으리라는 확신이 있을 때만 사용해야한다.
- \



